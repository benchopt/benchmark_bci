
#%%
from braindecode.datasets import MOABBDataset
from benchmark_utils import windows_data
from skorch.helper import SliceDataset
import numpy as np
from braindecode.augmentation import SmoothTimeMask
import torch
import matplotlib.pyplot as plt
import numpy.linalg as alg
from mpl_toolkits.mplot3d import Axes3D
from pyriemann.estimation import Covariances

dataset_name = "FakeDataset"
data = MOABBDataset(dataset_name=dataset_name,
                    subject_ids=None)

#%%


dataset, _ = windows_data(data, )

data_split_subject = dataset.split('subject')

data = data_split_subject['1']
X = SliceDataset(dataset, idx=0)
y = np.array([y for y in SliceDataset(dataset, idx=1)])

seed = 20200220
second = 0.2
sfreq = 250
transform = SmoothTimeMask(probability=0.5,
                           mask_len_samples=int(sfreq * second),
                           random_state=seed)

X_torch = torch.as_tensor(X).float()
y_torch = torch.as_tensor(y).float()
param_augm = transform.get_augmentation_params(X_torch,
                                               y_torch)
mls = param_augm['mask_len_samples']
msps = param_augm['mask_start_per_sample']

X_tr, _ = transform.operation(
                        X_torch,
                        None,
                        mask_len_samples=mls,
                        mask_start_per_sample=msps
                        )

X_tr = X_tr.numpy()


# A : matrice symétrique définie positive ,
# center: le centre de l'ellipsoide,
# affiche la représentation ellipsoidale d'une matrice symétrique 3x3

# donne une couleur à un tenseur en fonction de sa direction
def couleur_tenseur(M):
    i = np.argmax(np.linalg.eigvals(M))
    # indice de la valeur propre la plus grande

    vp = np.linalg.eig(M)[1][i]
    # vecteur propre de valeur propre maximale

    vp_n = (1 / np.linalg.norm(vp, 2)) * vp

    return vp_n

# pondère les couleurs d'un tenseurs pour qu'elle soit moins terne


def ponderer_couleur(liste):
    return liste


# A : matrice symétrique définie positive ,
# center: le centre de l'ellipsoide,
# affiche la représentation ellipsoidale d'une matrice symétrique 3x3

def afficher_tenseur(A, center):
    U, s, rotation = alg.svd(A)

    radii = 1.0/np.sqrt(s)

    u = np.linspace(0.0, 2.0 * np.pi, 30)
    v = np.linspace(0.0, np.pi, 30)
    x = radii[0] * np.outer((1/3)*np.cos(u), (1/3)*np.sin(v))
    y = radii[1] * np.outer((1/3)*np.sin(u), (1/3)*np.sin(v))
    z = radii[2] * np.outer((1/3)*np.ones_like(u), (1/3)*np.cos(v))

    for i in range(len(x)):
        for j in range(len(x)):
            [x[i, j], y[i, j], z[i, j]] = np.dot([x[i, j],
                                                  y[i, j],
                                                  z[i, j]], rotation) + center

    return ([x, y, z], radii)

# affiche les tenseurs d'une droite de matrices qui sont dans la liste ligne


def afficher_tenseurs_ligne(ligne):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    n = len(ligne)
    for x in range(n):
        A = ligne[x]
        center = [x, 0, 0]
        (l, rad) = afficher_tenseur(A, center)
        x1 = l[0]
        y1 = l[1]
        z1 = l[2]

        # Plot
        Couleur = couleur_tenseur(A)
        Couleurplus = ponderer_couleur(Couleur)
        a = Couleurplus[0]
        b = Couleurplus[1]
        c = Couleurplus[2]
        ax.plot_surface(x1, y1, z1,  rstride=4, cstride=4, color=(a, c, b))

        # Ajustement des axes
        max_radius = max(rad[0], rad[1], rad[2])
        for axis in 'xyz':
            getattr(ax, 'set_{}lim'.format(axis))((-1, 17))
# %%
